Docker is an open-source standalone application which works as an engine to run containerized application isolated from others. Docker can be defined as container management service.

Container is a standard unit of software that packages up code and all its dependencies so the application runs quickly from a computing environment to another, it packages applications as images to run them.

Virtualization allows using physical resources into many environments using hypervisors also known as virtual machine monitor(VMM), separate the physical resources from virtual enviroments.

	----------------			-----     -----     -----             -------------------
       |                |	               | App |   | App |   | App |           |   Containarized   |
       |  Applications  |                       -----     -----     -----             -------------------
       |________________|                      | OS  |   | OS  |   | OS  |           | A | B | C | D | E |
       |                |                       -----     -----     -----             -------------------
       | Operating      |                      |	Virualization    |           |       Docker      |
       |      Systems   |                       -------------------------             -------------------
       |________________|                      |       Hardware          |           |         OS        |
       |    Hardware    |                       -------------------------             -------------------
       |                |                                                            |      Hardware     |
        ----------------                                                              -------------------
    Traditional (server,laptop)




.Docker Architecture:
---------------------
Docker Image: read-only template with instructions for creating a Docker container
Docker Container: runnable instance of image
Docker Registry: stores Docker images, DockerHub is a public registry
Docker Client: using commands, client sends these commands to dockerd which carries them out. Docker commands use docker API
Docker daemon: listens for Docker API requests and manages Docker objects such as images, containers, networks, volumes
Docker Namespaces: used to provide isolated workspace(container), when running the container Docker creates a set of namespaces for that container. These name spaces provide a layer of isolation. Each aspect of a container runs in a separate namespace and its access is limited to that namespace.







        Client                                       Docker-Host                               Registry
 --------------------                          -------------------------                    -------------
|                    |                        |                         |                  | {DockerHub} |
| docker build-------|------------------------|------{docker daemon}    |                  |    ubuntu   |
| docker pull--------|---------------------/  | images /       container|         ---------|    image    |
| docker run---------|--------------------/   |  |debian|---------|a|   |         |          -------------
|  (commands)        |                        |  |ubuntu|         |b|   |         |
|                    |                        |      \__________________|----------         
 --------------------                          -------------------------



.Docker Commands:
-----------------
docker run <image> //to run a docker image installed and if not installed this command will search for the image, pull it then run it
docker ps -a | -all//to check all the containers
docker ps // to check the running containers
docker container ls -a //works same as docker ps -a
docker pull <image> // to pull a new image which isn't installed locally
docker rm <container_id> // to delete container
docker image rm <image_name> // to delete image
docker image rm <image_id> //to delete image
docker container run <container_id> //to run container
docker container run -d <container_id> //to run container in the background without logs on screen till container stop
docker inspect <container_id> //to get DockerFile of desired container - to get the ports look for exposed ports
docker logs <container_id> //to show logs in container
docker stats <container_id> //physical resources used
docker info //to get all docker information
docker inspect -f='{{range.NetworkSettings.Networks}}{{.IPAddress}}{{end}}' <container_id> //get container ip address
docker container run -d --publish 80:80 --name n1 nginx //publish to host on port 80 and name to set the container name as n1
docker container start <container_id> // to start container
docker container stop <container_id> //to stop container
docker exec -it <container_id> //get through the container as example nginx bash docker exec -it n1 bash
docker build -t <container_name_tag> . //to build from Dockerfile naming the image
docker volume ls //to list volumes

NOTES:!!!
---------
-f: --format
-it: --tty --interactive
-p: --publish
instead of container_id it can be replaced by 4_chars_hash - container name
-d: --deattach


.Docker Tags:
-------------


Docker Tags are reference to docker images, many tags can refer to a single image.
Default image is the latest tag
				image<-------redis:alpine------->tag
                            

.Image Layers:
--------------


App --> d12894 --> Layer
Apache --> 95fe2a --> Layer
Ubuntu --> 0f745 --> Layer


All these layers from os, server and app can be on a single image


.DockerFile:
------------


Docker can build images automatically by reading the instructions of a DockerFile.
DockerFile is a text document tgar contains all the commands a user could call on the command line to assemble an image


.Push on Dockerhub:
-------------------


After building the container ==> docker commit container_name username/image_name ==> docker login ==> docker push username/image_name



.Data Management from containers and images:
--------------------------------------------

Data are separated of concerns: Volumes - Bind Mounting - 

Volumes are stored in a part of the host filesystem which is managed by docker(/var/lib/docker/volumes)
Non-Docker processes won't modify the filesystem
Volumes are the best way to persist data in Docker
Volume can be mounted into multiple containers simultaneously

Bind Mounting may be stored anywhere on the host system
Non-Docker processes on the Docker host or a Docker container can modify it
To use bind mounts, file or directory doesn't exist on Docker host, created on demand



.Volumes:
---------


Volumes are where data container are stored
Check it using docker inspect container name as source on host and destination on container
Also volumes can be used on different containers
To separate volumes from generated naming when creating a container name it's volume using -v so it can be used on multiple containers

example:
docker pull mariadb //pull mariadb image 
docker run -d --name mariadb1 -e MARIADB_ROOT_PASSWORD=1234 mariadb //create mariadb1 container entering password as 1234
docker container inspect mariadb1 //check container volume and mount
docker run -d --name mariadb2 -e MARIADB_ROOT_PASSWORD=1234 -v mariad2_volume:/var/lib/mysql mariadb //give the container a named volume (/var/lib/mysql is the path to volume which is required for naming a volume)
docker volume create mariadb_volume_backup //create an empty volume named as mariadb_volume_backup
docker run -d --name mariadb3 -e MARIADB_ROOT_PASSWORD=1234 -v mariadb_volume_backup:/var/lib/mysql mariadb //assign the created volume to a new container
docker exec -it mariadb3 bash
root# mysql -u root -p
1234
MARIADB# show databases;
       # create database BACKUP_DATABASE;
       # exit;
root#exit

//create a new container with existing volume so both containers will be synced together
docker run -d --name mariadb-prod -e MARIADB_ROOT_PASSWORD=1234 -v mariadb_volume_backup:/var/lib/mysql mariadb
docker exec -it mariadb-prod bash
root# mysql -u root -p
1234
MARIADB#show databases;




.Bind Mounting:
---------------



Bind Mounting used as a shared folder between the host and the containers created
example:

mkdir data
cd data
touch data01.txt
docker container run -it --name alpine_container1 -v ${pwd}:/shared_folder alpine
/ # ls //in alpine_container1
cd shared_folder
ls
echo 'This is created from the host' >> data02.txt //in host
ls //in alpine_container1
cat data02.txt
echo 'This is created from container' > data03.txt //from container
ls //from host it should be seen


!Note: if changed the folder name as mounting in another container, data of the shared folder won't be affected
docker container run -it --name alpine2 -v ${pwd}:/sharepoint alpine
ls sharepoint //the items should be the same





.Networking:
------------


Docker networking is primarily used to establish communication between Docker containers and the outside world via the host machine where the Docker daemon is running
Container works by default as bridge
Networking types in Docker: Bridge - Host - None - Overlay - Macvlan
Host: Disables Docker's network isolation. It means containers see and use exactly the same network interfaces the host has available
None: The none network driver does not attach containers to any network, Containers do not access the external network or communicate with other containers
Overlay:
Macvlan:


example:
docker network ls  //to check network created and linked with drivers
docker network inspect <name> //to inspect the network and containers linked to this network
docker run -d -it --name ubuntu1 ubuntu //create new container
docker container ls //check if the new container is running
docker container inspect ubuntu1 //check it's ip
docker run -d -it --name ubuntu2 ubuntu //create new container
docker container inspect ubuntu2 //check ip
docker network inspect bridge //check containers attached to bridge network
docker network create --driver bridge n1 //create a new bridge network named n1
docker network ls //check n1 and driver
docker network inspect n1 //used to check attached containers and subnet on network
docker run --network=n1 -d -it --name ubuntu3 ubuntu //create new container
docker container inspect ubuntu3 //check the ip of container
docker run --network=n1 -d -it --name ubuntu4 ubuntu //create new container
docker container inspect ubuntu4 //check new container
docker network inspect n1 //check containers attached on n1
docker container stop ubuntu4 //stop container
docker network inspect n1 // now n1 will have one less container attached since it's turned off
docker network create --driver bridge --subnet 192.168.253.0/24 n2 //create a new bridge network with custom subnet
docker network ls //check n2 if created and it's subnet
docker network inspect n2 //check subnet and containers attached to the network
docker run --network=n2 -d -it --name ubuntu5 ubuntu //create new container
docker container ls //check if the new container is running
docker container inspect ubuntu5 //check the container ip
docker network disconnect n2 ubuntu5 //disconnect container from the desired network
docker network connect n1 ubuntu5 //connect container to desired network
docker container inspect ubuntu5 //check ip changed

!note ==> container even if disattached from network and joined other network won't turn down and will still be available

docker network inspect n1 //check attached containers
docker run --network=n1 -it --name alpine1 alpine ash
	/ # ping 172.19.0.2 //as example of network n1(same network)



Backend:
--------



						HyperV                                                                        WSL2
					     Older version							Windows subsystem linux(newer version)
					     windows 10(19H)




Docker compose:
---------------



compose is a tool for defining and running multi-container Docker applications on a single host, with compose YAML file is used to configure your application's services

YAML: Yet Another Markup Language
Service in YAML is container



Docker vs Docker Compose:
-------------------------



Docker works with only one container at a time and it's configuration
Docker compose is an automation inovation to create and manage many containers at a time
							


Docker Swarm:
-------------


Docker Swarm is a container orchestration tool that allows you to run and connect containers on multiple hosts. It can do tasks like scaling, starting a new container when one crashes, networking and many more



Kubernetes:
-----------



Kubernetes is a container orchestration tool similar to Docker Swarm
"K8s" orchastrates containerized applications to run on a cluster hosts. Kubernetes system automates the deployment and management of cloud native applications using on-premises infrastructure and cloud platforms
Docker



Docker Swarm vs Kubernetes:
---------------------------



Docker Swarm: to deploy multiple hosts(cluster) simple and scalable
Kubernetes: to manage a large deployment of scalable automated containers



Azure Container Instances(ACI):
-------------------------------



enables a dev to deploy containerson the Microsoft Azure public cloud without having to provision or manage any underlying infrastructure



Docker entrypoint vs CMD:
-------------------------



CMD cannot override the command but for entrypoint it can override
Example:
If created a docker container from a Dockerfile which has a cmd command with echo hello world ==> shows hello world but from the command to run the container I added echo Louay it shows only Louay without hello world.

For entrypoint taking the exact example it shows hello world Louay (overrides the command)