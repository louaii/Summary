Required to automate an infrastructure to manage all the running services from one place.

CM(configuration management): is a system engineering method that ensures a product's characteristics remain consistent during its life cycle, it provides a configuration model of the services, assets, and infrastructure by recording the relationships between service assets and configuration items(CI)
It also ensures that releases into controlled environments and operational use are completed on the basis of formal approvals. Configuration management may cover non-IT assets, work products used to develop the services, and configuration items required to support the services that are not formally classified as assets. Any change in configuration can dramatically impact: Peformance, Security, Functionality. Any component that requires management to deliver an IT service is considered part of the scope of configuration management. This process maintains information about any CI required to deliver an IT service, including its relationships and this information is managed throughout the life cycle of the CI. 
Configuration Management is to define and control the components of an IT service and its infrastructure, and maintain accurate configuration information. The configuration management application identifies, defines and tracks an organization's configuration items by creating and managing records for those items. Other service manager applications can then access these records from a central repository

_Roles of configuration management tools:
Configuration management tools allow modifications and deployments to be faster, repeatable, scalable, predictable and able to maintain the desired state, ehich brings controlled assets into an expected states.

Advantages of using configuration management tools include:

.Increase the efficiency with a well-defined configuration process that improves visibility and provides control with the help of tracking. 

.Optimize cost by having detailed knowledge of all the IT elements, which helps to avoid unnecessary duplication.

.Track requirements from specification to testing

.Identify and control software versions

.Enhances system and process reliability by detecting effects

.Manage the information about the configuration items

.Provides faster restoration of your service if a process failure occurs

.Facilitate the conduct of functional configuration audits

_Popular configuration management tools:
.Saltstack: Python-based open source configuration management tool used to remotely manage configuration items
.Ansible: Python-based configuration management tool considered as agentless configuration management tool
.Chef: Ruby-based configuration management tool having integration with most of the cloud-based platforms
.Puppet: Ruby DSL-based configuration management tool used for managing software, systems and network configuration items

_Ansible Overview:
.Ansible is an IT automation engine that automates cloud provising, configuration management, application deployment, intra-service orchestration, and a variety of other IT tasks.

.Ansible was built from the ground up for multi-tiered deployments and instead of controlling one system at a time, it models your IT architecture by defining how all of your systems interact.

.Ansible uses playbook to describe automation jobs, which are written in YAML(human-readable data serialization language which is mainly used for configuration files)

.Ansible designed for multi-tiered deployment.

.Ansible models IT infrastructure by interrelating all the systems, It was constructed for multi-level use from the ground up.

_Ansible components:

Instead of logging into each of these remote nodes and carrying out your tasks, you can comfortably do so from a central location and comfortably manage your servers. This is benefical when you want to maitain consistency in application deployment, reduce human error and automating repetitive and somewhat mundane tasks


_YAML scripting:
YAML syntax is simpler for humans to read and write than other popular data formats like XML and JSON.
Further, there are libraries available in most programming languages for working with YAML, Ansible uses it to express Ansible playbooks.
For Ansible, nearly every YAML file starts with a list, every item in the list is a key or value pair list, also known as a hash or dictionary
Every YAML file optionally starts with (---) and ends with (...)
Example of YAML file:
---
   james:
      name:james john
      rollNo: 34
      div: B
      sex: male
...

Rules when creating YAML file:
When you are creating a file in YAML, you should remeber the following basic, YAML is case-sensitive, the files should have (.yaml) as the extension. YAML does not allow the use of tabs while creating YAML files spaces are allowed instead.

--------------------------------------------------------------------------------------------------------------------------------------------------------
Ansible linux installation:

sudo apt install ansible -t buster-backports

if error occured
	==> nano /etc/apt/sources.list.d/backports.list
		==> deb http://deb.debian.org/debian/buster-backports main contrib non-free
		==> deb -src http://deb.debian.org/debian/buster-backports main contrib non-free
CTRL+O

sudo apt update

inventory file in ansible is as index in html which maitains groups and it's assets

nano inventory
[all] #group all
192.168.1.16 #ip_address
louay.ubuntu@aws.com #dns
[all:vars]
ansible-python-interpreter=/usr/bin/python3 #hides warnings
docs ==> https://docs.ansible.com/ansible/2.9/reference_appendencies/interpreter_discovery.html

_ansible all#desired_group -i#for_path inventory#filename -m#modules command#desired_module -a#arguments date#desired_argument
_ansible all -i inventory -u#user root#desired_user command -a "date" #gives back date from user root -f#forks_to_choose_the_number_of_devices_at_same_time(default is five) 1#one_device_at_a_time
_ansible all -i inventory -u root -a "df -h" #servers storage space
_ansible all -i inventory -u root -a "free -m" #memory space 
_ansible all -i inventory -u root -m apt -a "name=apache2 state=present" #install apache2
#!!! in warnings if changed is true it is changed manually if false then it's changing through ansible
_ansible all -i inventory -u root -m apt -a "name=apache2 state=absent" #delete apache2
_ansible all -i inventory -u root -m service -a "name=apache2 state=stopped" #stop apache2 service services(started,stopped,restarted,reloaded)
_ansible all -i inventory -u root -m service -a "name=apache2 state=started" --limit 192.168.1.16 #to limit the command only on desired machine through ip or dns this command starts the apache2 only on 192.168.1.16 even if the all group has other machines in it

Ansible vs Ansible-Playbook:
----------------------------


Ansible: Simple Commands, Can't be posted on a repo, usefull for a single time or error occured
Ansible-Playbook: .yml files as scripts, can be saved as file, simple when configuring, pushed to repos

main.yml:

---
  - name: Install and configure apache
    hosts: all
    user: root
    pre-tasks:
            - name: Update apt cache
              apt:
                  update_cache: true
                  cache_valid_time: true
           handlers:
                  - name: Restart Apache
                    service:
                          name: apache2
                          state: restarted
          tasks:
              - name: Install Apache
                apt:
                  name: apache2
                  state: present
   - name: Configure Update
     template:
            src: apache.conf.j2
            dest: /etc/apache2/apache.conf
            owner: root
            group: root
            mode: 777
     notify: Restart apache

==> Open terminal: ansible-playbook -i inventory main.yml




Ansible Roles:
--------------

mkdir roles && cd roles
ansible-galaxy search postgres #this command is used to search in ansible for a desired keyword
ansible-galaxy init base_role #creates templated_directory named base_role
ansible-galaxy init apache
ansible-galaxy init postgres

#delete .travis.yml, files/, tests/
look for main.yml in tasks/

base/tasks/main.yml
---
- name: Update APT Cache
  apt: update_cache=true cache_valid_time=3600

#delete all files in base and keep tasks and README.md

apache/tasks/main.yml
---
- name: Install apache
  apt:
    name: apache2
    state: present
- name: Configure Apache
  template: 
     src: apache.conf.j2
     dest: /etc/apache2/apache.conf
     owner: root
     group: root
     mode: 0644
notify: restart apache

#copy apache.conf.j2 in apache/template
#delete .travis.yml tests/ files/

apache/handlers/main.yml
---
- name: restart apache
  service:
    name: apache2
    state: restarted


postgres/tasks/main.yml
---
- name: Install postgres
  apt: 
   name: postgressql-11
   state: present
#delete .travis.yml tests/ files/

/main.yml #this is the root main.yml in the ansible-playbook that calls the other .yml files

---
- name: Baseline Configuration
  hosts: #desired ip - dns - group
  user: root
  roles:
    - role: base

- name: Apache Configuration
  hosts: all
  user: root
  roles:
   - role: apache

# edit groups in inventory

# in terminal: ansible-playbook -i inventory main.yml





Ansible Vault:
--------------

mkdir env
cd env
mkdir testing
mkdir production
cd testing
../../inventory
mkdir group-vars
cd group-vars
mkdir apache
cd apache
touch vars.yml
cd ..
touch all
nano all
ansible-python-interpreter: /usr/bin/python3

vi ~/Desktop/ansible-playbook/env/testing/inventory

[all]
192.168.1.16
192.168.1.17

[apache]
192.168.1.16

vi ~/Desktop/ansible-playbook/roles/apache/tasks/main.yml

---
- name: Install Apache & requirements
  apt: 
    name: ['apache2', 'python-passlib']
    state: present
- name: Configure apache
  template:
       src: apache.config.j2
       dest: /etc/apache2/apache.conf
       owner: root
       group: root
       mode: 0640
  notify: Restart apache
- name: Add user to password file
  htpasswd: "{{ apache_htpasswd }}"
  path: /etc/apache2/.htpasswd
  name: "{{ item.username }}"
  password: "{{ item.password }}"
  owner: root
  group: www-data
  mode: 0640
loop: "{{ users }}"
no_log: True

#cp /etc/apache2/sites-enabled ~/Desktop/ansible-playbook/roles/apache/templates
#mv sites-enabled 000-default.conf.j2

#above </VirtualHost>
<Directrory "/var/www/docs">
   AuthType Basic
   AuthName Documents
   AuthBasicProvider file
   AuthUserFile "/etc/apache2/.htpasswd" #"{{ apache_htpasswd }}"
   Require valid_user
</Directory>
</VirtualHost>

- name: Configure Default App
  template:
    src: 000-default.conf.j2
    dest: /etc/apache2/sites-enabled/000-default.conf
    owner: root
    group: root
    mode: 0640
notify: Restart apache

vi ~/Desktop/ansible-playbook/env/testing/group-vars/apache/vars.yml

users:
  - username: louay
    password: '1234'

vi ~/Desktop/ansible-playbook/roles/apache/default/main.yml

---
- apache_htpasswd: "/etc/apache2/.htpasswd"


terminal: ansible-playbook -i env/testing/inventory main.yml -u root
touch ~/Desktop/ansible-playbook/env/testing/group-vars/apache/vault.yml

#copy paste the content of vars.yml to vault.yml

terminal: ansible-vault encrypt ~/Desktop/ansible-playbook/env/testing/groupvars/apache/vault.yml

enter password then files open

ansible-playbook -i ~/Desktop/ansible-playbook/env/testing/inventory main.yml -u root --ask-vault-pass

Ansible Security:
-----------------


/ansible-playbook/env/testing/inventory/main.yml

[all]
192.168.1.17
192.168.1.16

/ansible-playbook/roles/base/tasks

---
- name: Update APT Cache
  apt: update_cache=true cache_valid_time=3600

- include: ssh.yml

- include: users.yml
  tags: users

/ansible-playbook/roles/base/tasks/ssh.yml

---
- name: ssh - Install ssh
  apt: 
    name: openssh-server
    state: present

- name: ssh - create authorized_keys directory
  file: 
     path: /etc/ssh/authorized_keys
     state: directory
     owner: root
     group: root
     mode: 0755

- name: ssh - Configure SSH
  template: 
        src: ssh_config.j2
        dest: /etc/ssh/sshd_config
        owner: root
        group: root
        mode: 0644

notify: ssh - reload

- name: ssh - Ensure ssh is running
  service: 
        name: sshd
        state: started


/ansible-playbook/roles/base/tasks/users.yml

---
- name: users - Load users
  include_vars: users.yml

- name: users - create user
  user: 
     name: "{{ item.username }}"
  loop: "{{ users }}
  loop_control:
            label: "{{ item.username }}"

- name: users - Install user ssh keys
  authorized_key:
              user: "{{ item.username }}"
              key: "{{ item.public_key }}"
              state: present
              exclusive: yes
              path: "/etc/ssh/authorized_keys/{{ item.username }}"
              manage_dir: no
  loop: "{{ users }}"
  loop_control:
            label: "{{ item.username }}"

- name: users - set ssh key file permissions
  file: 
     path: "/etc/ssh/authorized_keys/{{ item.username }}"
     owner: "{{ item.username }}"
     group: "{{ item.username }}"
     mode: 0400
  loop: "{{ users }}"
  loop_control:
            label: "{{ item.username }}"

/ansible-playbook/roles/base/vars/users.yml
users: 
- username: louay
  public_key: id_rsa.pub

/ansible-playbook/roles/base//handlers/main.yml
---
- name: ssh-reload
  service:
       name: sshd
       state: reloaded

/ansible-playbook/roles/base/templates/sshd_config.j2
Port 22
PermitRootLogin no
AuthorizedKeysFile /etc/ssh/authorized_keys/%u
PasswordAuthentication no
ChallengePasswordResponse no
UsePAM
X11Forwarding yes
PrintMotd no
UseDNS no 
AcceptEnv Lang LC_*

#override default of no subsystems
subsystem sftp /usr/lib/openssh/sftp_server

terminal:
$ansible-playbook -i ./env/testing/invenory main.yml -u louay



Ansible Plugins:
----------------

Check Docs

Write Plugins with python

Call Back Plugins

cd ansible-playbook
mkdir callback_plugins
touch time_taken.py

#copy code from:
https://docs.ansible.com/ansible/latest/dev_guide/developing_plugins.html#callback_plugins

#change CALLBACK_NEEDS_WHITELIST False

$ansible-playbook -i ./env/testing/inventory/main.yml










 



