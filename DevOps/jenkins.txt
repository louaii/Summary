Jenkins is used for fast software delivery(CI/CD), it allows automating repetitive tasks and reducing human errors, easily integrates with various tools improving workflow and collaboration between teams

Agile: Plan, code, build, test, release, deploy, operate, monitor

CI: Continuous integration - CD: Continuous Delivery

 
Continuous Integration:
Software development practice that requires team members to integrate their work frequently, the goal of CI is to detect and fix integration issues early which is achieved by automating software testing and building everytime a team member pulses changes to the code repo


Continuous Deployment/Delivery:
Once the app is built it must be deployed in a testing environment and finally deliver it to production, it can be implemented automatically or manually


Pre-staging --> functional and performance --> deploy --> manual/automatic --> production and monitor


Architecture and Components:
----------------------------
Master(jenkins core tomcat ssh 22, plugins JNLP 5000, Jobs, Users cloud api, security)

Slave(Agent)


Installation:
-------------

using docker

docker network create jenkins
docker network ls
cp bridge jenkins

mkdir jenkins_data

docker run --name=jenkins-master --network=jenkins -d -p 8080:8080 -p 5000:5000 -v ./jenkins_data:/var/jenkins_home jenkins/jenkins

docker ps


(The "Restaurant" Model)
Think of Jenkins as the Manager of a professional kitchen.

The Trigger (The Order): A customer places an order. In Jenkins, this is usually a developer pushing code to GitHub.

The Pipeline (The Recipe): The manager has a specific set of steps to follow (Wash vegetables → Chop → Cook → Plate).

The Actions (The Cooking): These are the actual commands (like npm install or docker build) that happen inside those steps.

The Result (The Meal): If everything goes well, you get a working app. If the "Cook" step fails, the Manager (Jenkins) screams "Fire!" (sends an email or Slack alert).

